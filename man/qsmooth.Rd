% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/qsmooth.R, R/qstats.R
\docType{methods}
\name{show}
\alias{show}
\alias{qsmooth}
\alias{qstats}
\title{qsmooth}
\usage{
qsmooth(object, groupFactor, batch = NULL, normFactors = NULL,
  window = 0.05)

qstats(object, groupFactor, qRange, window = 0.05)
}
\arguments{
\item{object}{an object which is inherited from an 
\code{eSet} such as an \code{ExpressionSet} or 
\code{MethylSet} object. The \code{object} can also be a 
data frame or matrix with observations
(e.g. probes or genes) on the rows and samples as the 
columns.}

\item{groupFactor}{a group level continuous or categorial 
covariate associated with each sample or column in the 
\code{object}. The order of the \code{groupFactor} must 
match the order of the columns in \code{object}.}

\item{batch}{(Optional) batch covariate (multiple 
batches are not allowed). 
If batch covariate is provided, \code{Combat()} from 
\code{sva} is used prior to qsmooth normalization to 
remove batch effects. See \code{Combat()} for more details.}

\item{normFactors}{optional normalization scaling factors.}

\item{window}{window size for running median which is 
a fraction of the number of rows in \code{object}. 
Default is 0.05.}

\item{object}{an object which is inherited from an 
\code{eSet} such as an \code{ExpressionSet} or 
\code{MethylSet} object. The \code{object} can also be a 
data frame or matrix with observations
(e.g. probes or genes) on the rows and samples as the 
columns.}

\item{groupFactor}{a group level continuous or categorial 
covariate associated with each sample or column in the 
\code{object}. The order of the \code{groupFactor} must 
match the order of the columns in \code{object}.}

\item{window}{window size for running median which is 
a fraction of the number of rows in \code{object}. 
Default is 0.05.}
}
\value{
A normalized matrix of values after applying 
smoothed quantile normalization.

A list of quantile statistics including 
\item{Q}{sample quantiles}
\item{Qref}{reference quantile}
\item{Qhat}{linear model fit at each quantile}
\item{SST}{total sum of squares}
\item{SSB}{between sum of squares}
\item{SSE}{within sum of squares}
\item{roughWeights}{SSE / SST}
\item{smoothWeights}{smoothed weights computed using a 
running median with a given \code{window} size.}
}
\description{
This function applies a generalization of 
quantile normalization called smoothed quantile 
normalization. This function defines the qsmooth class 
and constructor.

This function is a helper function that 
computes quantile statistics for the function 
\code{qsmooth}.
}
\details{
Quantile normalization is one of the most widely used 
normalization tools for data analysis in genomics. Although it 
was originally developed for gene expression microarrays it is
now used across many different high-throughput applications 
including RNAseq and ChIPseq. The methodology 
relies on the assumption that observed changes in the empirical 
distribution of samples are due to unwanted variability. 
Because the data is transformed to remove these differences 
it has the potential to remove interesting biologically driven
global variation. Therefore, applying quantile normalization, 
or other global normalization methods that rely on similar 
assumptions, may not be an appropriate depending on the type 
and source of variation. 

This function computes a weight at every 
quantile that compares the variability between groups 
relative to within groups. In one extreme quantile 
normalization is applied and in the other extreme quantile 
normalization within each biological condition is applied. 
The weight shrinks the group-level quantile normalized data 
towards the overall reference quantiles if variability 
between groups is sufficiently smaller than the variability 
within groups. 
See the vignette for more details.
}
\examples{
library(SummarizedExperiment)
library(bodymapRat)
data(bodymapRat)
# select lung and liver samples, stage 21 weeks, and bio reps
keepColumns = (colData(bodymapRat)$organ \%in\% c("Lung", "Liver")) & 
         (colData(bodymapRat)$stage == 21) & 
         (colData(bodymapRat)$techRep == 1)
keepRows = rowMeans(assay(bodymapRat)) > 10 # Filter out low counts
bodymapRat <- bodymapRat[keepRows,keepColumns]
pd <- colData(bodymapRat)
pd$group <- paste(pd$sex, pd$organ, sep="_")

qsNorm <- qsmooth(object = asssay(bodymapRat)[keepRows, keepColumns], 
                  groupFactor = colData(bodymapRat)[keepColumns, 
                  ]$organ)

library(SummarizedExperiment)
library(bodymapRat)
data(bodymapRat)
# select lung and liver samples, stage 21 weeks, and bio reps
keepColumns = (colData(bodymapRat)$organ \%in\% c("Lung", "Liver")) & 
         (colData(bodymapRat)$stage == 21) & 
         (colData(bodymapRat)$techRep == 1)
keepRows = rowMeans(assay(bodymapRat)) > 10 # Filter out low counts
bodymapRat <- bodymapRat[keepRows,keepColumns]
pd <- colData(bodymapRat)

qs <- qstats(object = assay(bodymapRat), groupFactor = pd$organ, 
             window = 0.05)

}
